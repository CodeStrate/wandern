from wandern.constants import (
    REGEX_MIGRATION_PARSER,
    REGEX_TIMESTAMP,
    REGEX_REVISION_ID,
    REGEX_REVISES,
    REGEX_MESSAGE,
    REGEX_AUTHOR,
    REGEX_TAGS,
    DEFAULT_FILE_FORMAT,
    DEFAULT_MIGRATION_TABLE,
    DEFAULT_CONFIG_FILENAME,
    parse_migration_content,
    CompatibleMatch,
)


def test_basic_migration_regex_parsing():
    """Test parsing a basic migration file with all required fields."""
    migration_content = """/*
    Autogenerated by Wandern, please add your migration SQL here.

    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0002
    Revises: 0001
    Message: create table 2
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0002"
    assert match.group("revises") == "0001"
    assert match.group("message") == "create table 2"
    assert match.group("tags") is None
    assert match.group("author") is None
    assert match.group("up_sql").strip() == ""
    assert match.group("down_sql").strip() == ""


def test_migration_with_tags_and_author():
    """Test parsing migration with optional tags and author fields."""
    migration_content = """/*
    Autogenerated by Wandern, please add your migration SQL here.

    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0003
    Revises: 0002
    Message: add user authentication
    Author: John Doe <john@example.com>
    Tags: auth, security, users
    */

    -- UP
    CREATE TABLE users (id INTEGER PRIMARY KEY);

    -- DOWN
    DROP TABLE users;
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0003"
    assert match.group("revises") == "0002"
    assert match.group("message") == "add user authentication"
    assert match.group("tags") == "auth, security, users"
    assert match.group("author") == "John Doe <john@example.com>"
    assert "CREATE TABLE users" in match.group("up_sql")
    assert "DROP TABLE users" in match.group("down_sql")


def test_migration_without_autogenerated_header():
    """Test parsing when user removes the autogenerated header."""
    migration_content = """/*
    Custom header added by user

    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0004
    Revises: 0003
    Message: custom migration
    */

    -- UP
    ALTER TABLE users ADD COLUMN email VARCHAR(255);

    -- DOWN
    ALTER TABLE users DROP COLUMN email;
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0004"
    assert match.group("revises") == "0003"
    assert match.group("message") == "custom migration"
    assert "ALTER TABLE users ADD COLUMN" in match.group("up_sql")
    assert "ALTER TABLE users DROP COLUMN" in match.group("down_sql")


def test_migration_with_extra_comments():
    """Test parsing with additional comments and notes in header."""
    migration_content = """/*
    This is a very important migration!
    Please review carefully before applying.

    Timestamp: 2024-11-19 00:55:16
    Note: This timestamp was manually adjusted

    Revision ID: 0005
    Revises: 0004
    Message: critical database changes

    Additional notes:
    - This migration affects performance
    - Run during maintenance window

    Author: Jane Smith
    Tags: critical, performance

    End of header comments
    */

    -- UP
    CREATE INDEX idx_users_email ON users(email);
    -- This index improves login performance

    -- DOWN
    DROP INDEX idx_users_email;
    -- Remove the performance index
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0005"
    assert match.group("revises") == "0004"
    assert match.group("message") == "critical database changes"
    assert match.group("tags") == "critical, performance"
    assert match.group("author") == "Jane Smith"
    assert "CREATE INDEX" in match.group("up_sql")
    assert "DROP INDEX" in match.group("down_sql")


def test_migration_with_multiline_message():
    """Test parsing migration with multiline message."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0006
    Revises: 0005
    Message: complex migration with
    multiple lines in message
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("revision_id") == "0006"
    # The regex should capture up to the first newline for message
    assert "complex migration with" in match.group("message")


def test_migration_with_complex_sql():
    """Test parsing migration with complex SQL containing comments."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0007
    Revises: 0006
    Message: complex SQL migration
    */

    -- UP
    /* Create the main table */
    CREATE TABLE products (
        id INTEGER PRIMARY KEY,
        name VARCHAR(255) NOT NULL,
        price DECIMAL(10, 2)
    );

    -- Add some initial data
    INSERT INTO products (name, price) VALUES
        ('Product 1', 29.99),
        ('Product 2', 39.99);

    -- DOWN
    /* Clean up in reverse order */
    DROP TABLE products;
    -- Note: This will remove all data!
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("revision_id") == "0007"
    assert match.group("message") == "complex SQL migration"

    up_sql = match.group("up_sql")
    down_sql = match.group("down_sql")

    assert "CREATE TABLE products" in up_sql
    assert "INSERT INTO products" in up_sql
    assert "DROP TABLE products" in down_sql
    assert "This will remove all data!" in down_sql


def test_migration_with_unusual_spacing():
    """Test parsing with unusual spacing and formatting."""
    migration_content = """/*


    Timestamp:    2024-11-19 00:55:16


    Revision ID:0008
    Revises:  0007
    Message:   unusual spacing test


    */

    --UP

    SELECT 1;

    --DOWN

    SELECT 0;
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp").strip() == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0008"
    assert match.group("revises") == "0007"
    assert match.group("message").strip() == "unusual spacing test"


def test_migration_with_tags_only():
    """Test parsing migration with tags but no author."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0009
    Revises: 0008
    Message: migration with tags only
    Tags: test, tags
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("tags") == "test, tags"
    assert match.group("author") is None


def test_migration_with_author_only():
    """Test parsing migration with author but no tags."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0010
    Revises: 0009
    Message: migration with author only
    Author: Test Author
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("tags") is None
    assert match.group("author") == "Test Author"


def test_migration_with_empty_sql_sections():
    """Test parsing migration with completely empty SQL sections."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0011
    Revises: 0010
    Message: empty migration
    */

    -- UP

    -- DOWN

    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("up_sql").strip() == ""
    assert match.group("down_sql").strip() == ""


def test_invalid_migration_missing_fields():
    """Test that regex fails gracefully with missing required fields."""
    migration_content = """/*
    Just some random comment
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is None


def test_migration_with_alphanumeric_revision_ids():
    """Test parsing with alphanumeric revision IDs."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: abc123
    Revises: def456
    Message: alphanumeric revision test
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("revision_id") == "abc123"
    assert match.group("revises") == "def456"


def test_edge_case_special_characters_in_message():
    """Test parsing with special characters in message."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0012
    Revises: 0011
    Message: migration with special chars: @#$%^&*()
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("message") == "migration with special chars: @#$%^&*()"


def test_real_world_example():
    """Test with the actual migration file from the project."""
    migration_content = """/*
    Autogenerated by Wandern, please add your migration SQL here.

    Timestamp: 2024-11-19 00:55:16

    Revision ID: 0002
    Revises: 0001
    Message: create table 2
    */

    -- UP

    -- DOWN
    """
    match = parse_migration_content(migration_content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 00:55:16"
    assert match.group("revision_id") == "0002"
    assert match.group("revises") == "0001"
    assert match.group("message") == "create table 2"
    assert match.group("tags") is None
    assert match.group("author") is None
    assert match.group("up_sql").strip() == ""
    assert match.group("down_sql").strip() == ""


def test_regex_parse_with_groupdict():
    migration_content = """/*
    This is a very important migration!
    Please review carefully before applying.

    Timestamp: 2024-11-19 00:55:16
    Note: This timestamp was manually adjusted

    Revision ID: 0005
    Revises: 0004
    Message: critical database changes

    Additional notes:
    - This migration affects performance
    - Run during maintenance window

    Author: Jane Smith
    Tags: critical, performance

    End of header comments
    */

    -- UP
    CREATE INDEX idx_users_email ON users(email);
    -- This index improves login performance

    -- DOWN
    DROP INDEX idx_users_email;
    -- Remove the performance index
    """

    match = parse_migration_content(migration_content)

    assert match
    match_dict = match.groupdict()
    assert match_dict["timestamp"] == "2024-11-19 00:55:16"
    assert match_dict["revision_id"] == "0005"
    assert match_dict["revises"] == "0004"
    assert match_dict["message"] == "critical database changes"
    assert match_dict["author"] == "Jane Smith"
    assert match_dict["tags"] == "critical, performance"


def test_default_constants():
    """Test that default constants have expected values."""
    assert DEFAULT_FILE_FORMAT == "{version}_{slug}_{message}"
    assert DEFAULT_MIGRATION_TABLE == "wd_migrations"
    assert DEFAULT_CONFIG_FILENAME == ".wd.json"


def test_regex_pattern_type():
    """Test that REGEX_MIGRATION_PARSER is a compiled regex pattern."""
    import re

    assert isinstance(REGEX_MIGRATION_PARSER, type(re.compile(r"")))
    assert REGEX_MIGRATION_PARSER.flags & re.DOTALL
    assert REGEX_MIGRATION_PARSER.flags & re.VERBOSE


def test_migration_regex_with_reordered_fields():
    """Test parsing migration with comment fields in different order."""
    migration_content = """/*
    Author: Jane Smith
    Message: add user authentication
    Timestamp: 2024-11-20 10:30:45
    Tags: users, auth
    Revision ID: 0003
    Revises: 0002
    */

    -- UP
    CREATE TABLE auth_tokens;
    -- DOWN
    DROP TABLE auth_tokens;
    """

    match = parse_migration_content(migration_content)
    assert match is not None

    # Verify all fields are correctly extracted despite different order
    assert match.group("timestamp") == "2024-11-20 10:30:45"
    assert match.group("revision_id") == "0003"
    assert match.group("revises") == "0002"
    assert match.group("message") == "add user authentication"
    assert match.group("author") == "Jane Smith"
    assert match.group("tags") == "users, auth"

    # Verify SQL sections
    assert "CREATE TABLE auth_tokens" in match.group("up_sql")
    assert "DROP TABLE auth_tokens" in match.group("down_sql")


def test_migration_regex_case_insensitive_fields():
    """Test parsing migration with case-insensitive field names."""
    migration_content = """/*
    timestamp: 2024-11-21 15:45:00
    revision id: 0004
    REVISES: 0003
    MESSAGE: case test migration
    author: Test Author
    TAGS: test, case
    */

    -- UP
    CREATE INDEX idx_test ON test_table(column);
    -- DOWN
    DROP INDEX idx_test;
    """

    match = parse_migration_content(migration_content)
    assert match is not None

    # Verify all fields are correctly extracted despite different cases
    assert match.group("timestamp") == "2024-11-21 15:45:00"
    assert match.group("revision_id") == "0004"
    assert match.group("revises") == "0003"
    assert match.group("message") == "case test migration"
    assert match.group("author") == "Test Author"
    assert match.group("tags") == "test, case"


def test_individual_regex_patterns():
    """Test individual regex patterns work correctly."""
    # Test REGEX_TIMESTAMP
    content = "Some text\nTimestamp: 2024-11-19 15:30:45\nOther text"
    match = REGEX_TIMESTAMP.search(content)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 15:30:45"

    # Test case insensitive
    content_lower = "timestamp: 2024-11-19 15:30:45"
    match = REGEX_TIMESTAMP.search(content_lower)
    assert match is not None
    assert match.group("timestamp") == "2024-11-19 15:30:45"

    # Test REGEX_REVISION_ID
    content = "Revision ID: abc123"
    match = REGEX_REVISION_ID.search(content)
    assert match is not None
    assert match.group("revision_id") == "abc123"

    # Test with space variations
    content = "Revision   ID:def456"
    match = REGEX_REVISION_ID.search(content)
    assert match is not None
    assert match.group("revision_id") == "def456"

    # Test REGEX_REVISES
    content = "Revises: previous_rev"
    match = REGEX_REVISES.search(content)
    assert match is not None
    assert match.group("revises") == "previous_rev"

    # Test REGEX_MESSAGE
    content = "Message: This is a test migration message"
    match = REGEX_MESSAGE.search(content)
    assert match is not None
    assert match.group("message") == "This is a test migration message"

    # Test REGEX_AUTHOR
    content = "Author: John Doe <john@example.com>"
    match = REGEX_AUTHOR.search(content)
    assert match is not None
    assert match.group("author") == "John Doe <john@example.com>"

    # Test REGEX_TAGS
    content = "Tags: tag1, tag2, tag3"
    match = REGEX_TAGS.search(content)
    assert match is not None
    assert match.group("tags") == "tag1, tag2, tag3"


def test_individual_regex_patterns_no_match():
    """Test individual regex patterns return None when no match found."""
    no_match_content = "Some random text without any patterns"

    assert REGEX_TIMESTAMP.search(no_match_content) is None
    assert REGEX_REVISION_ID.search(no_match_content) is None
    assert REGEX_REVISES.search(no_match_content) is None
    assert REGEX_MESSAGE.search(no_match_content) is None
    assert REGEX_AUTHOR.search(no_match_content) is None
    assert REGEX_TAGS.search(no_match_content) is None


def test_compatible_match_span_start_end_methods():
    """Test CompatibleMatch span, start, and end methods."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16
    Revision ID: test123
    Revises: prev456
    Message: test migration
    */

    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    match = parse_migration_content(migration_content)
    assert match is not None

    # Test span method
    span = match.span()
    assert isinstance(span, tuple)
    assert len(span) == 2
    assert span[0] >= 0
    assert span[1] > span[0]

    # Test start method
    start = match.start()
    assert isinstance(start, int)
    assert start >= 0
    assert start == span[0]

    # Test end method
    end = match.end()
    assert isinstance(end, int)
    assert end > start
    assert end == span[1]


def test_compatible_match_invalid_content():
    """Test CompatibleMatch raises ValueError for invalid content."""
    invalid_content = "This is not a valid migration file"

    try:
        CompatibleMatch(invalid_content)
        assert False, "Expected ValueError to be raised"
    except ValueError as e:
        assert "Invalid migration file format" in str(e)


def test_compatible_match_missing_required_fields():
    """Test CompatibleMatch raises ValueError when required fields are missing."""
    # Missing timestamp
    content_missing_timestamp = """/*
    Revision ID: test123
    Revises: prev456
    Message: test migration
    */
    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    try:
        CompatibleMatch(content_missing_timestamp)
        assert False, "Expected ValueError to be raised"
    except ValueError as e:
        assert "Missing required fields in migration file" in str(e)

    # Missing revision_id
    content_missing_revision_id = """/*
    Timestamp: 2024-11-19 00:55:16
    Revises: prev456
    Message: test migration
    */
    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    try:
        CompatibleMatch(content_missing_revision_id)
        assert False, "Expected ValueError to be raised"
    except ValueError as e:
        assert "Missing required fields in migration file" in str(e)

    # Missing revises
    content_missing_revises = """/*
    Timestamp: 2024-11-19 00:55:16
    Revision ID: test123
    Message: test migration
    */
    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    try:
        CompatibleMatch(content_missing_revises)
        assert False, "Expected ValueError to be raised"
    except ValueError as e:
        assert "Missing required fields in migration file" in str(e)

    # Missing message
    content_missing_message = """/*
    Timestamp: 2024-11-19 00:55:16
    Revision ID: test123
    Revises: prev456
    */
    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    try:
        CompatibleMatch(content_missing_message)
        assert False, "Expected ValueError to be raised"
    except ValueError as e:
        assert "Missing required fields in migration file" in str(e)


def test_compatible_match_group_nonexistent_field():
    """Test CompatibleMatch.group() returns None for non-existent fields."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16
    Revision ID: test123
    Revises: prev456
    Message: test migration
    */

    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    match = parse_migration_content(migration_content)
    assert match is not None

    # Test accessing non-existent field
    assert match.group("nonexistent_field") is None
    assert match.group("") is None


def test_compatible_match_groupdict_immutability():
    """Test that groupdict() returns a copy and modifications don't affect original."""
    migration_content = """/*
    Timestamp: 2024-11-19 00:55:16
    Revision ID: test123
    Revises: prev456
    Message: test migration
    Author: Test Author
    Tags: test, migration
    */

    -- UP
    CREATE TABLE test;
    -- DOWN
    DROP TABLE test;
    """

    match = parse_migration_content(migration_content)
    assert match is not None

    # Get groupdict
    original_dict = match.groupdict()
    modified_dict = match.groupdict()

    # Modify the copy
    modified_dict["timestamp"] = "modified_timestamp"
    modified_dict["new_field"] = "new_value"

    # Original should be unchanged
    assert original_dict["timestamp"] == "2024-11-19 00:55:16"
    assert "new_field" not in original_dict

    # Getting groupdict again should return original values
    fresh_dict = match.groupdict()
    assert fresh_dict["timestamp"] == "2024-11-19 00:55:16"
    assert "new_field" not in fresh_dict


def test_parse_migration_content_with_invalid_format():
    """Test parse_migration_content returns None for completely invalid formats."""
    invalid_formats = [
        "",  # Empty string
        "/* No proper structure */",  # Missing UP/DOWN sections
        "-- UP\n-- DOWN",  # Missing comment block
        "/*\nSome comment\n*/\nNo UP/DOWN sections",  # Missing UP/DOWN
        "Random text",  # Completely wrong format
    ]

    for invalid_content in invalid_formats:
        result = parse_migration_content(invalid_content)
        assert result is None, f"Expected None for content: {invalid_content}"


def test_regex_patterns_with_edge_cases():
    """Test regex patterns with various edge cases and formatting."""
    # Test timestamp with different formats
    timestamp_cases = [
        "Timestamp: 2024-01-01 00:00:00",
        "timestamp: 2024-12-31 23:59:59",
        "TIMESTAMP: 2024-06-15 12:30:45",
        "Timestamp:2024-11-19 15:30:45",  # No space after colon
        "Timestamp:  2024-11-19 15:30:45",  # Multiple spaces
    ]

    for case in timestamp_cases:
        match = REGEX_TIMESTAMP.search(case)
        assert match is not None, f"Failed to match: {case}"
        assert "2024-" in match.group("timestamp")

    # Test revision ID with different formats
    revision_cases = [
        "Revision ID: abc123",
        "revision id: def456",
        "REVISION ID: xyz789",
        "Revision ID:test123",  # No space after colon
        "Revision   ID: spaced123",  # Multiple spaces in field name
    ]

    for case in revision_cases:
        match = REGEX_REVISION_ID.search(case)
        assert match is not None, f"Failed to match: {case}"
        assert match.group("revision_id") is not None

    # Test message with special characters and line endings
    message_cases = [
        "Message: Simple message",
        "message: Message with special chars: @#$%^&*()",
        "MESSAGE: Message ending with newline\n",
        "Message: Message with numbers 123 and symbols !@#",
        "Message:No space after colon",
    ]

    for case in message_cases:
        match = REGEX_MESSAGE.search(case)
        assert match is not None, f"Failed to match: {case}"
        assert match.group("message") is not None
